<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hello, loving heart</title>
    <!-- 引入 Pacifico 字体 -->
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; cursor: pointer; /* 提示可点击 */ }
        .input_video { display: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>

    <!-- 增加 playsinline 属性以更好适配 iOS 浏览器 -->
    <video class="input_video" playsinline muted autoplay></video>

    <!-- 依赖库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // =========================================================================
        // ★★★ 参数配置区域 ★★★
        // =========================================================================
        const CONFIG = {
            // --- 1. 基础外观 ---
            backgroundColor: 0x000000,
            particleColor: 0x00BFFF,
            particleCount: 4500,
            particleSize: 0.38,
            fogColor: 0x000010,

            // --- 2. 显示内容 ---
            textOneFinger: "For PP",
            textTwoFingers: "2026.2.1",

            // --- 3. 尺寸与位置 ---
            heartScale: 16,
            textScale: 0.12,

            // [修改] 基础摄像机距离 (这是横屏时的标准距离)
            baseCameraDistance: 28,

            // --- 4. 动画与交互 ---
            morphSpeed: 0.1,
            rotationSensitivity: 3.5,
            heartBeatStrength: 0.25,

            // --- 5. 手势缩放配置 ---
            handScaleMultiplier: 9.0,
            minScale: 0.2,
            maxScale: 3.0
        };
        // =========================================================================


        // --- 全局状态 ---
        const STATE = {
            mode: 'heart',
            targetScale: 1,
            currentScale: 1,
            isHandPresent: false,
            targetRotationY: 0
        };

        // --- Three.js 初始化 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(CONFIG.backgroundColor);
        scene.fog = new THREE.FogExp2(CONFIG.fogColor, 0.01);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        // 初始位置稍后由 updateCameraLayout 设置

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- ★★★ 核心修改：响应式布局函数 ★★★ ---
        function updateCameraLayout() {
            // 1. 更新渲染器大小
            renderer.setSize(window.innerWidth, window.innerHeight);

            // 2. 更新摄像机长宽比
            const aspect = window.innerWidth / window.innerHeight;
            camera.aspect = aspect;
            camera.updateProjectionMatrix();

            // 3. 智能计算摄像机距离 (Z轴)
            // 逻辑：如果屏幕比 1:1 更窄 (竖屏)，就需要把摄像机拉远，否则文字显示不全
            // 0.8 是一个修正系数，因为文字比较宽
            if (aspect < 1.0) {
                // 竖屏模式 (手机)
                camera.position.z = CONFIG.baseCameraDistance / (aspect * 0.85);
            } else {
                // 横屏模式 (电脑)
                camera.position.z = CONFIG.baseCameraDistance;
            }
        }

        // 初始化调用一次
        updateCameraLayout();

        // 监听窗口大小变化
        window.addEventListener('resize', updateCameraLayout);
        // ---------------------------------------------


        // --- 粒子纹理 ---
        function createBrightTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');

            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
            grad.addColorStop(0.2, 'rgba(255, 255, 255, 0.9)');
            grad.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)');
            grad.addColorStop(1, 'rgba(255, 255, 255, 0)');

            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 64, 64);

            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // --- 粒子系统构建 ---
        const particleGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.particleCount * 3);

        const heartPositions = new Float32Array(CONFIG.particleCount * 3);
        const text1Positions = new Float32Array(CONFIG.particleCount * 3);
        const text2Positions = new Float32Array(CONFIG.particleCount * 3);

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const particleMaterial = new THREE.PointsMaterial({
            color: CONFIG.particleColor,
            size: CONFIG.particleSize,
            map: createBrightTexture(),
            transparent: true,
            opacity: 0.95,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);

        // --- 形状生成 ---
        function generateHeart() {
            for (let i = 0; i < CONFIG.particleCount; i++) {
                let x, y, z, p;
                do {
                    x = (Math.random() * 2 - 1) * 1.5;
                    y = (Math.random() * 2 - 1) * 1.5;
                    z = (Math.random() * 2 - 1) * 1.5;
                    let a = x * x + 2.25 * y * y + z * z - 1;
                    p = a * a * a - x * x * z * z * z - 0.1125 * y * y * z * z * z;
                } while (p > 0);

                x *= CONFIG.heartScale;
                y *= CONFIG.heartScale;
                z *= CONFIG.heartScale;

                heartPositions[i * 3] = x;
                heartPositions[i * 3 + 1] = z;
                heartPositions[i * 3 + 2] = y;

                positions[i * 3] = x;
                positions[i * 3 + 1] = z;
                positions[i * 3 + 2] = y;
            }
        }

        function generateTextToBuffer(text, buffer, fontSize = 140) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 1024;
            canvas.height = 512;

            ctx.font = `${fontSize}px "Pacifico", cursive`;
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const validPixels = [];

            for (let y = 0; y < canvas.height; y += 3) {
                for (let x = 0; x < canvas.width; x += 3) {
                    if (data[(y * canvas.width + x) * 4 + 3] > 128) {
                        validPixels.push({
                            x: (x - canvas.width / 2) * CONFIG.textScale,
                            y: -(y - canvas.height / 2) * CONFIG.textScale,
                            z: 0
                        });
                    }
                }
            }

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const targetIndex = i % validPixels.length;
                const pixel = validPixels[targetIndex];
                buffer[i * 3] = pixel.x;
                buffer[i * 3 + 1] = pixel.y;
                buffer[i * 3 + 2] = (Math.random() - 0.5) * 3;
            }
        }

        // --- 手势识别 ---
        const videoElement = document.querySelector('.input_video');

        function onResults(results) {
            let handsData = results.multiHandLandmarks;

            if (handsData && handsData.length > 0) {
                STATE.isHandPresent = true;
                const lm = handsData[0];

                // 旋转
                const handX = lm[9].x;
                STATE.targetRotationY = (0.5 - handX) * CONFIG.rotationSensitivity;

                // 手势状态
                const indexUp = lm[8].y < lm[6].y;
                const middleUp = lm[12].y < lm[10].y;
                const ringUp = lm[16].y < lm[14].y;
                const pinkyUp = lm[20].y < lm[18].y;

                const isOneFinger = indexUp && !middleUp && !ringUp && !pinkyUp;
                const isTwoFingers = indexUp && middleUp && !ringUp && !pinkyUp;

                if (isTwoFingers) {
                    STATE.mode = 'text_date';
                    STATE.targetScale = 1;
                } else if (isOneFinger) {
                    STATE.mode = 'text_pp';
                    STATE.targetScale = 1;
                } else {
                    STATE.mode = 'heart';
                    const thumbTip = lm[4];
                    const pinkyTip = lm[20];
                    const distance = Math.sqrt(
                        Math.pow(thumbTip.x - pinkyTip.x, 2) +
                        Math.pow(thumbTip.y - pinkyTip.y, 2)
                    );
                    let scale = (distance - 0.05) * CONFIG.handScaleMultiplier;
                    STATE.targetScale = Math.max(CONFIG.minScale, Math.min(CONFIG.maxScale, scale));
                }

            } else {
                STATE.isHandPresent = false;
                STATE.mode = 'heart';
                STATE.targetScale = 1;
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, // [优化] 手机端使用轻量模型以提升性能
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraUtils.start().catch(console.error);

        // --- 动画循环 ---
        generateHeart();
        setTimeout(() => {
            generateTextToBuffer(CONFIG.textOneFinger, text1Positions, 140);
            generateTextToBuffer(CONFIG.textTwoFingers, text2Positions, 130);
        }, 1500);

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();

            STATE.currentScale += (STATE.targetScale - STATE.currentScale) * 0.1;
            particles.scale.setScalar(STATE.currentScale);

            const positionsArray = particles.geometry.attributes.position.array;

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                let tx, ty, tz;
                if (STATE.mode === 'text_date') {
                    tx = text2Positions[ix];
                    ty = text2Positions[iy];
                    tz = text2Positions[iz];
                } else if (STATE.mode === 'text_pp') {
                    tx = text1Positions[ix];
                    ty = text1Positions[iy];
                    tz = text1Positions[iz];
                } else {
                    tx = heartPositions[ix];
                    ty = heartPositions[iy];
                    tz = heartPositions[iz];
                    tx += Math.sin(time * 3 + i) * CONFIG.heartBeatStrength;
                    ty += Math.cos(time * 2 + i) * CONFIG.heartBeatStrength;
                }

                positionsArray[ix] += (tx - positionsArray[ix]) * CONFIG.morphSpeed;
                positionsArray[iy] += (ty - positionsArray[iy]) * CONFIG.morphSpeed;
                positionsArray[iz] += (tz - positionsArray[iz]) * CONFIG.morphSpeed;
            }
            particles.geometry.attributes.position.needsUpdate = true;

            if (STATE.isHandPresent) {
                scene.rotation.y += (STATE.targetRotationY - scene.rotation.y) * 0.1;
            } else {
                scene.rotation.y = Math.sin(time * 0.3) * 0.3;
            }

            renderer.render(scene, camera);
        }

        animate();

        // --- 点击屏幕切换全屏 ---
        document.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                // 尝试进入全屏
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen().catch(err => console.log(err));
                } else if (document.documentElement.webkitRequestFullscreen) { // iOS/Safari 兼容
                    document.documentElement.webkitRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
            }
        });

    </script>
</body>
</html>
